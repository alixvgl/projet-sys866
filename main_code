import numpy as np
from typing import Dict, Tuple, List, Any
import math
import random
from pulp import LpProblem, LpMinimize, LpVariable, lpSum, value, PULP_CBC_CMD
import numpy as np
from typing import Dict, Any
import copy

# =============================================================================
# D√âFINITION DES PARAM√àTRES ET DE L'√âTAT INITIAL
# =============================================================================

HORIZON_T = 24 # Horizon de temps de l'optimisation (= 24 semaines = 6 mois)
M_SCENARIOS = 100 # Nombre de sc√©narios pour le SAA
COSTS = {'a': 5, 'b': 1, 'c': 100} # Co√ªts de pond√©ration de chaque flux pour la fonction objectif
INITIAL_K = 8000 # Nombre de vaccin initial
K_RENOUV_AMOUNT = 8000 # Quantit√© du renouvellement du stock de vaccins toutes les semaines
RENOUVELLEMENT_PERIOD = 1 # P√©riode de renouvellement en semaines

# √âtat Initial

S_1_INITIAL = {
    't': 0,
    'Stock': {'K': INITIAL_K},

    'Region_01': {'S': 1000000, 'E': 2000, 'I': 2000, 'R': 5000, 'D': 200, 'V': 0, 'P': 1009200}, # La M√©galopole
    'Region_02': {'S':  500000, 'E': 1000, 'I': 1000, 'R': 2500, 'D': 100, 'V': 0, 'P':  504600},
    'Region_03': {'S':  250000, 'E':  500, 'I':  500, 'R': 1250, 'D':  50, 'V': 0, 'P':  252300},
    'Region_04': {'S':  100000, 'E':  200, 'I':  200, 'R':  500, 'D':  20, 'V': 0, 'P':  100920},
    'Region_05': {'S':   50000, 'E':  100, 'I':  100, 'R':  250, 'D':  10, 'V': 0, 'P':   50460},
    'Region_06': {'S':   25000, 'E':   50, 'I':   50, 'R':  125, 'D':   5, 'V': 0, 'P':   25230},
    'Region_07': {'S':   10000, 'E':   20, 'I':   20, 'R':   50, 'D':   2, 'V': 0, 'P':   10092},
    'Region_08': {'S':    5000, 'E':   10, 'I':   10, 'R':   25, 'D':   1, 'V': 0, 'P':    5046},
    'Region_09': {'S':    2500, 'E':    5, 'I':    5, 'R':   12, 'D':   0, 'V': 0, 'P':    2522},
    'Region_10': {'S':    1000, 'E':    2, 'I':    2, 'R':    5, 'D':   0, 'V': 0, 'P':    1009}, # Le Hameau

    'P_mean': {f'Region_{i:02d}': {'beta': 0.14, 'nu': 0.012, 'alpha': 0.964, 'gamma': 0.213, 'eta': 0.161} for i in range(1, 11)}
}

S_2_INITIAL = {
    't': 0,
    'Stock': {'K': INITIAL_K},

    # --- GROUPE A (Fort E, Faible I) ---
    'Region_01': {'S': 100000, 'E': 5000, 'I': 100, 'R': 500, 'D': 10, 'V': 0, 'P': 105610},
    'Region_02': {'S': 100000, 'E': 4500, 'I': 100, 'R': 500, 'D': 10, 'V': 0, 'P': 105110},
    'Region_03': {'S': 100000, 'E': 4000, 'I': 100, 'R': 500, 'D': 10, 'V': 0, 'P': 104610},

    # --- GROUPE B (Faible E, Fort I) ---
    'Region_04': {'S': 90000, 'E': 500, 'I': 3000, 'R': 1000, 'D': 300, 'V': 0, 'P': 94800},
    'Region_05': {'S': 90000, 'E': 500, 'I': 2500, 'R': 1000, 'D': 250, 'V': 0, 'P': 94250},
    'Region_06': {'S': 90000, 'E': 500, 'I': 2000, 'R': 1000, 'D': 200, 'V': 0, 'P': 93700},

    # --- GROUPE C (Beaucoup de R) ---
    'Region_07': {'S': 50000, 'E': 100, 'I': 100, 'R': 40000, 'D': 2000, 'V': 0, 'P': 92200},
    'Region_08': {'S': 60000, 'E': 100, 'I': 100, 'R': 30000, 'D': 1500, 'V': 0, 'P': 91700},

    # --- GROUPE D (Presque rien) ---
    'Region_09': {'S': 100000, 'E': 10, 'I': 10, 'R': 0, 'D': 0, 'V': 0, 'P': 100020},
    'Region_10': {'S': 100000, 'E': 5, 'I': 5, 'R': 0, 'D': 0, 'V': 0, 'P': 100010},

    # --- PARAM√àTRES IDENTIQUES ---
    'P_mean': {f'Region_{i:02d}': {'beta': 0.14, 'nu': 0.012, 'alpha': 0.964, 'gamma': 0.213, 'eta': 0.161} for i in range(1, 11)}
}

S_3_INITIAL = {
    't': 0,
    'Stock': {'K': INITIAL_K},

    'Region_01': {'S': 500000, 'E': 50, 'I': 10, 'R': 0, 'D': 0, 'V': 0, 'P': 500060},
    'Region_02': {'S': 500000, 'E': 50, 'I': 10, 'R': 0, 'D': 0, 'V': 0, 'P': 500060},

    'Region_03': {'S': 50000, 'E': 200, 'I': 50, 'R': 100, 'D': 10, 'V': 0, 'P': 50360},
    'Region_04': {'S': 50000, 'E': 200, 'I': 50, 'R': 100, 'D': 10, 'V': 0, 'P': 50360},
    'Region_05': {'S': 50000, 'E': 200, 'I': 50, 'R': 100, 'D': 10, 'V': 0, 'P': 50360},
    'Region_06': {'S': 50000, 'E': 200, 'I': 50, 'R': 100, 'D': 10, 'V': 0, 'P': 50360},
    'Region_07': {'S': 50000, 'E': 200, 'I': 50, 'R': 100, 'D': 10, 'V': 0, 'P': 50360},
    'Region_08': {'S': 50000, 'E': 200, 'I': 50, 'R': 100, 'D': 10, 'V': 0, 'P': 50360},

    'Region_09': {'S': 4000, 'E': 500, 'I': 500, 'R': 0, 'D': 20, 'V': 0, 'P': 5020},
    'Region_10': {'S': 4000, 'E': 500, 'I': 500, 'R': 0, 'D': 20, 'V': 0, 'P': 5020},

    'P_mean': {f'Region_{i:02d}': {'beta': 0.14, 'nu': 0.012, 'alpha': 0.964, 'gamma': 0.213, 'eta': 0.161} for i in range(1, 11)}
}

def K_renouv_func(t):
    if t % RENOUVELLEMENT_PERIOD == 0:
        return K_RENOUV_AMOUNT
    else:
        return 0
    
# =============================================================================
# G√âN√âRATION DE SC√âNARIOS POUR LE SAA
# =============================================================================

def ajuster_beta_dynamique(S_t):
    """
    Ajuste la moyenne de Beta en fonction de la charge infectieuse actuelle.
    Simule une politique gouvernementale :
    - Si beaucoup d'infect√©s -> Confinement (Beta baisse)
    - Si peu d'infect√©s -> Rel√¢chement (Beta remonte vers sa valeur naturelle)
    """
    S_ajuste = copy.deepcopy(S_t)
    regions = [k for k in S_t.keys() if k not in ['Stock', 't', 'P_mean']]
    
    SEUIL_ALERTE = 0.05  # Si 5% de la population est infect√©e (I)
    BETA_NATUREL = 0.30  # Taux sans masque ni geste barri√®re
    BETA_CONFINEMENT = 0.08 # Taux sous confinement strict
    
    for region in regions:
        I = S_t[region]['I']
        P = S_t[region]['P']
        taux_infection = I / P if P > 0 else 0
        
        current_beta_mean = S_t['P_mean'][region]['beta']
        

        if taux_infection > SEUIL_ALERTE:
            nouveau_beta = 0.8 * current_beta_mean + 0.2 * BETA_CONFINEMENT
        else:

            nouveau_beta = 0.9 * current_beta_mean + 0.1 * BETA_NATUREL

        S_ajuste['P_mean'][region]['beta'] = nouveau_beta
        
    return S_ajuste

def calculer_nu_dynamique(state_region):
    """
    Calcule le taux de vaccination volontaire (nu) en fonction des morts.
    """
    D = state_region['D']
    P = state_region['P']
    
    if P == 0: return 0
    
    # Param√®tres de comportement
    NU_BASE = 0.012      # 1.2% des gens se font vacciner par semaine si tout va bien
    NU_MAX = 0.50       # Capacit√© maximale du syst√®me ou limite d'acceptation (50%/semaine)
    FACTEUR_PEUR = 20.0 # √Ä quel point les morts motivent les gens
    
    ratio_morts = D / P
   
    nu_calcule = NU_BASE + (FACTEUR_PEUR * ratio_morts)
    
    return min(NU_MAX, nu_calcule)

def generer_parametres_aleatoires(S_t, ecart_type_ratio=0.2):
    """
    G√©n√®re uniquement les param√®tres √©pid√©miologiques al√©atoires (ind√©pendamment de x).
    Utilis√© dans le SAA pour g√©n√©rer les sc√©narios.
    """
    S_dynamique = ajuster_beta_dynamique(S_t)

    params_t = {}
    regions = [k for k in S_t.keys() if k != 'Stock' and k != 't' and k != 'P_mean']

    for region in regions:
        
        params_region = S_dynamique['P_mean'][region]
        nu_moyen_dynamique = calculer_nu_dynamique(S_t[region])

        # Tirage des param√®tres al√©atoires
        beta_t_i = np.abs(np.random.normal(params_region['beta'], ecart_type_ratio * params_region['beta']))       
        nu_t_i = np.abs(np.random.normal(nu_moyen_dynamique, ecart_type_ratio * nu_moyen_dynamique))

        alpha_t_i = np.abs(np.random.normal(params_region['alpha'], ecart_type_ratio * params_region['alpha']))
        gamma_t_i = np.abs(np.random.normal(params_region['gamma'], ecart_type_ratio * params_region['gamma']))
        eta_t_i = np.abs(np.random.normal(params_region['eta'], ecart_type_ratio * params_region['eta']))

        # S'assurer que les probabilit√©s/taux sont dans [0, 1]
        params_t[region] = {
            'beta': np.clip(beta_t_i, 0, 1),
            'nu': np.clip(nu_t_i, 0, 1),
            'alpha': np.clip(alpha_t_i, 0, 1),
            'gamma': np.clip(gamma_t_i, 0, 1),
            'eta': np.clip(eta_t_i, 0, 1),
        }

    return params_t


def generer_scenario_seirdv(S_t, x_t, ecart_type_ratio=0.2):
    """
    Simule la transition stochastique SEIRDV pour la p√©riode t -> t+1.

    G√©n√®re un sc√©nario d'informations exog√®nes (flux Delta) W_t+1,
    et les param√®tres √©pid√©miologiques tir√©s au hasard pour cette r√©gion et cette p√©riode.

    """
    W_t_plus_1 = {}
    params_t = generer_parametres_aleatoires(S_t, ecart_type_ratio)
    regions = [k for k in S_t.keys() if k != 'Stock' and k != 't' and k != 'P_mean']

    for region in regions:
        region_data = S_t[region]

        # R√©cup√©rer les √©tats de population
        S_pop = max(0, region_data['S'])
        E_pop = max(0, region_data['E'])
        I_pop = max(0, region_data['I'])
        P_tot = region_data['P']

        # Application de la d√©cision x_t (vaccination de campagne uniquement)
        x_t_i = max(0, min(x_t.get(region, 0), S_pop))

        # PAS DE VACCINATION SPONTAN√âE - uniquement la campagne
        Delta_S_V = 0

        # Population saine restante pour l'INFECTION (apr√®s vaccination de campagne)
        S_risk_for_E = max(0, S_pop - x_t_i)

        # Calcul de la probabilit√© de Contamination (S -> E)
        if P_tot > 0 and I_pop > 0:
            p_SE_t_i = params_t[region]['beta'] * I_pop / P_tot
            p_SE_t_i = np.clip(p_SE_t_i, 0, 1)
        else:
            p_SE_t_i = 0

        # Flux 1: Contamination (S -> E)
        if S_risk_for_E > 0:
            Delta_S_E = np.random.binomial(n=int(S_risk_for_E), p=p_SE_t_i)
        else:
            Delta_S_E = 0

        # Flux 2: Infection (E -> I)
        p_EI_t_i = params_t[region]['alpha']
        if E_pop > 0:
            Delta_E_I = np.random.binomial(n=int(E_pop), p=p_EI_t_i)
        else:
            Delta_E_I = 0

        # Flux 3 & 4: Retrait (I -> R ou D)
        p_Retrait_total = params_t[region]['gamma']

        # Tirage du nombre total d'individus quittant I
        if I_pop > 0:
            Delta_I_Retrait = np.random.binomial(n=int(I_pop), p=p_Retrait_total)
        else:
            Delta_I_Retrait = 0

        # R√©partition du retrait total (D√©c√®s vs Gu√©rison)
        eta_t_i = params_t[region]['eta']

        # Tirage pour la proportion de d√©c√®s parmi ceux qui se retirent
        if Delta_I_Retrait > 0:
            Delta_I_D = np.random.binomial(n=Delta_I_Retrait, p=eta_t_i)
            Delta_I_R = Delta_I_Retrait - Delta_I_D
        else:
            Delta_I_D = 0
            Delta_I_R = 0

        # Enregistrement des flux (W_t+1)
        W_t_plus_1[region] = {
            'Delta_S_E': Delta_S_E,
            'Delta_E_I': Delta_E_I,
            'Delta_I_R': Delta_I_R,
            'Delta_I_D': Delta_I_D,
            'Delta_S_V': Delta_S_V,
            'x_t_planifie': x_t_i,
        }

    return W_t_plus_1, params_t

# =============================================================================
# POLITIQUE PFA
# =============================================================================

def solve_pfa_policy(S_t):
    """
    Politique PFA Modifi√©e (Proportionnelle) :
    - La r√©gion la plus critique re√ßoit 40% du stock (ou son besoin max).
    - Le reste du stock est r√©parti entre les autres r√©gions proportionnellement √† leur score.

    Score de priorit√© : Pr_i = I_i / P_i
    """
    regions = [k for k in S_t.keys() if k not in ['Stock', 't', 'P_mean']]
    K_t = S_t['Stock']['K']
    x_t_star = {r: 0.0 for r in regions}

    # 1. Calcul des scores
    priorities = {}
    for region in regions:
        vals = S_t[region]
        if vals['P'] > 0:
            score = vals['I'] / vals['P']
        else:
            score = 0
        
        priorities[region] = {
            'score': score,
            'S': vals['S'] # Capacit√© max de vaccination (population saine)
        }

    # Tri d√©croissant
    sorted_regions = sorted(priorities.keys(), key=lambda r: priorities[r]['score'], reverse=True)
    
    if not sorted_regions or K_t <= 0:
        return x_t_star

    # --- √âTAPE 1 : Allocation √† la r√©gion prioritaire (Top 1) ---
    top_region = sorted_regions[0]
    
    # 60% du stock total cible
    target_top_allocation = 0.60 * K_t
    
    # On donne le min entre : 40% du stock, OU le stock total dispo, OU le besoin r√©el (S)
    allocation_top = min(target_top_allocation, K_t, priorities[top_region]['S'])
    
    x_t_star[top_region] = allocation_top
    
    # --- √âTAPE 2 : Allocation aux autres r√©gions (Les 40% restants) ---
    stock_restant = K_t - allocation_top
    other_regions = sorted_regions[1:]
    
    if stock_restant > 0 and other_regions:
        # Somme des scores des autres r√©gions pour le calcul du ratio
        total_score_others = sum(priorities[r]['score'] for r in other_regions)
        
        for region in other_regions:
            # Si les scores sont nuls (personne n'est malade ailleurs), on ne distribue rien
            if total_score_others > 0:
                ratio = priorities[region]['score'] / total_score_others
                
                # Allocation th√©orique bas√©e sur le ratio
                allocation_theorique = ratio * stock_restant
                
                # On ne peut pas donner plus que le nombre de personnes saines (S)
                allocation_reelle = min(allocation_theorique, priorities[region]['S'])
                
                x_t_star[region] = allocation_reelle
            else:
                x_t_star[region] = 0.0

    return x_t_star


# =============================================================================
# R√âSOLUTION DU PROBL√àME SAA
# =============================================================================

def solve_saa_problem(S_t, N_scenarios, costs):
    
    regions = [k for k in S_t.keys() if k not in ['Stock', 't', 'P_mean']]
    K_t = S_t['Stock']['K']

    # D√©finition du probl√®me d'optimisation
    model = LpProblem("SAA_Vaccine_Allocation", LpMinimize)

    # Variables de d√©cision: x_t^i (Quantit√© de vaccins √† allouer √† la r√©gion i)
    x_vars = LpVariable.dicts("x", regions, lowBound=0, cat='Continuous')

    total_cost = []

    # Construction de la Fonction Objectif SAA
    for m in range(N_scenarios):
        # G√©n√©rer UNIQUEMENT les param√®tres al√©atoires (ind√©pendamment de x)
        P_m = generer_parametres_aleatoires(S_t)

        cost_immediat = 0
        
        for region in regions:
            i = region
            S_i = S_t[i]['S']
            E_i = S_t[i]['E']
            I_i = S_t[i]['I']
            P_i = S_t[i]['P']

            # Param√®tres al√©atoires pour ce sc√©nario m
            beta_i_m = P_m[i]['beta']
            alpha_i_m = P_m[i]['alpha']
            gamma_i_m = P_m[i]['gamma']
            eta_i_m = P_m[i]['eta']

            # CALCUL DES ESP√âRANCES CONDITIONNELLES sachant x_t et les param√®tres P_m

            # La population √† risque pour la contamination = Sains apr√®s vaccination de campagne
            E_S_risk_for_E = S_i - x_vars[i]

            # Probabilit√© de contamination S->E
            if P_i > 0 and I_i > 0:
                p_SE_i_m = beta_i_m * I_i / P_i
            else:
                p_SE_i_m = 0

            # Esp√©rance du flux S->E
            E_Delta_S_E = p_SE_i_m * E_S_risk_for_E

            # Esp√©rance du flux E->I
            E_Delta_E_I = alpha_i_m * (E_i + E_Delta_S_E)

            # Esp√©rance du flux I -> (R + D)
            E_Delta_I_Retrait = gamma_i_m * I_i

            # Esp√©rance du flux I->D (d√©c√®s)
            E_Delta_I_D = eta_i_m * E_Delta_I_Retrait

            # Co√ªt total pour ce sc√©nario m et cette r√©gion i
            cost_immediat += (costs['a'] * E_Delta_S_E + 
                                 costs['b'] * E_Delta_E_I + 
                                 costs['c'] * E_Delta_I_D)

        total_cost.append(cost_immediat)

    # La fonction objectif est la moyenne des co√ªts sur tous les sc√©narios
    model += lpSum(total_cost) / N_scenarios, "Total_SAA_Cost"

    # Contrainte 1: Ne pas d√©passer le stock disponible
    model += lpSum([x_vars[i] for i in regions]) <= K_t, "Stock_Constraint"
    
    # Contrainte 2 : R√©partir "√©quitablement le stock" (= Ne pas allouer + de 40% du stock √† une r√©gion)
    EQUITY_RATIO = 0.4 
    max_per_region = K_t * EQUITY_RATIO
    for region in regions:
        if K_t > 0:
            model += x_vars[region] <= max_per_region, f"Equity_Constraint_{region}"

    for region in regions:
        S_actuel = S_t[region]['S']
        
        nu_actuel = calculer_nu_dynamique(S_t[region])
        max_personnes_volontaires = S_actuel * nu_actuel
        # Contrainte 3 : On ne peut pas vacciner plus que les volontaires
        #model += x_vars[region] <= max_personnes_volontaires, f"Contrainte_Nu_Dynamique_{region}"
        
        # Contrainte 4 : On ne peut pas vacciner plus de gens qu'il n'y en a 
        model += x_vars[region] <= S_actuel

        
    # R√©solution du probl√®me
    model.solve(PULP_CBC_CMD(msg=0))

    # Extraction du r√©sultat
    if model.status == 1:
        x_t_star = {region: value(x_vars[region]) for region in regions}
    else:
        print(f"Echec de la r√©solution")
        x_t_star = {r: 0.0 for r in regions}

    return x_t_star

# =============================================================================
# FONCTION DE TRANSITION
# =============================================================================
def update_state(S_t, x_t_star, K_renouv_func):
    """
    Fonction de Transition d'√©tat S_t -> S_t+1
    Mise √† jour dynamique de Nu (volont√©) et Beta (politique sanitaire).
    """
    S_next = copy.deepcopy(S_t)

    # Incertitude r√©alis√©e (flux r√©els)
    W_real, P_real = generer_scenario_seirdv(S_t, x_t_star)

    # Mise √† jour du Temps
    S_next['t'] = S_t['t'] + 1

    # Mise √† jour du Stock
    quantite_allouee = sum(x_t_star.values())
    stock_restant = max(0, S_t['Stock']['K'] - quantite_allouee)
    
    # Renouvellement p√©riodique
    if S_next['t'] % RENOUVELLEMENT_PERIOD == 0:
        stock_restant += K_RENOUV_AMOUNT
    S_next['Stock']['K'] = stock_restant

    # Mise √† jour par R√©gion
    regions = [k for k in S_t.keys() if k not in ['Stock', 't', 'P_mean']]
    
    for region in regions:
        # Mise √† jour des Compartiments
        Delta_S_E = W_real[region]['Delta_S_E']
        Delta_E_I = W_real[region]['Delta_E_I']
        Delta_I_R = W_real[region]['Delta_I_R']
        Delta_I_D = W_real[region]['Delta_I_D']
        x_t_i = x_t_star.get(region, 0)

        S_prev = S_t[region]['S']
        
        # Calcul des nouveaux stocks
        S_next[region]['S'] = max(0, S_prev - x_t_i - Delta_S_E)
        S_next[region]['E'] = max(0, S_t[region]['E'] + Delta_S_E - Delta_E_I)
        S_next[region]['I'] = max(0, S_t[region]['I'] + Delta_E_I - Delta_I_R - Delta_I_D)
        S_next[region]['R'] = max(0, S_t[region]['R'] + Delta_I_R)
        S_next[region]['D'] = max(0, S_t[region]['D'] + Delta_I_D)
        S_next[region]['V'] = max(0, S_t[region]['V'] + x_t_i)
        
        # Recalcul de la population totale vivante
        S_next[region]['P'] = (S_next[region]['S'] + S_next[region]['E'] + 
                               S_next[region]['I'] + S_next[region]['R'] + 
                               S_next[region]['V'])

        # Mise √† jour dynamique des param√®tres

        # Mise √† jour de Nu
        nouvelle_envie_nu = calculer_nu_dynamique(S_next[region])
        S_next['P_mean'][region]['nu'] = nouvelle_envie_nu

        # Mise √† jour de Beta
        I_actuel = S_next[region]['I']
        P_actuel = S_next[region]['P']
        taux_infection = I_actuel / P_actuel if P_actuel > 0 else 0
        
        # R√©cup√©ration des seuils
        SEUIL_ALERTE = 0.05       
        BETA_NATUREL = 0.30       
        BETA_CONFINEMENT = 0.08   
        
        current_beta_mean = S_t['P_mean'][region]['beta']
        
        if taux_infection > SEUIL_ALERTE:
            nouveau_beta = 0.8 * current_beta_mean + 0.2 * BETA_CONFINEMENT
        else:
            nouveau_beta = 0.9 * current_beta_mean + 0.1 * BETA_NATUREL
            
        S_next['P_mean'][region]['beta'] = nouveau_beta

    return S_next

def update_state_old(S_t, x_t_star, K_renouv_func):
    """
    Fonction de Transition d'√©tat S_t -> S_t+1 en utilisant la r√©alisation r√©elle de l'incertitude W_real.
    """
    S_next = copy.deepcopy(S_t)

    # Obtenir la r√©alisation r√©elle de l'incertitude W_real
    W_real, P_real = generer_scenario_seirdv(S_t, x_t_star)

    # Mise √† jour du temps et du stock de vaccins
    S_next['t'] = S_t['t'] + 1

    # D√©duction de l'allocation du stock
    S_next['Stock']['K'] = S_t['Stock']['K'] - np.sum(list(x_t_star.values()))

    # Renouvellement bas√© sur le NOUVEAU temps (t+1)
    # Si on est au d√©but d'un nouveau cycle (t+1 % 4 == 0), on AJOUTE 5000 vaccins au stock
    if S_next['t'] % RENOUVELLEMENT_PERIOD == 0:
        S_next['Stock']['K'] += K_RENOUV_AMOUNT  # Ajout de nouveaux vaccins

    # Mise √† jour des compartiments pour chaque r√©gion
    regions = [k for k in S_t.keys() if k != 'Stock' and k != 't' and k != 'P_mean']
    for region in regions:
        # Flux observ√©s (pas de Delta_S_V car pas de vaccination spontan√©e)
        Delta_S_E_real = W_real[region]['Delta_S_E']
        Delta_E_I_real = W_real[region]['Delta_E_I']
        Delta_I_R_real = W_real[region]['Delta_I_R']
        Delta_I_D_real = W_real[region]['Delta_I_D']

        # Allocation de la campagne
        x_t_i = x_t_star.get(region, 0)

        # Mettre √† jour BETA : maintenir l'√©volution du beta r√©el (tir√© al√©atoirement dans W_real)
        S_next['P_mean'][region]['beta'] = P_real[region]['beta']

        # Mise √† jour des compartiments (avec garde-fous pour √©viter les valeurs n√©gatives)
        # PAS de Delta_S_V car pas de vaccination spontan√©e
        S_next[region]['S'] = max(0, S_t[region]['S'] - x_t_i - Delta_S_E_real)
        S_next[region]['E'] = max(0, S_t[region]['E'] + Delta_S_E_real - Delta_E_I_real)
        S_next[region]['I'] = max(0, S_t[region]['I'] + Delta_E_I_real - Delta_I_R_real - Delta_I_D_real)
        S_next[region]['R'] = max(0, S_t[region]['R'] + Delta_I_R_real)
        S_next[region]['D'] = max(0, S_t[region]['D'] + Delta_I_D_real)
        S_next[region]['V'] = max(0, S_t[region]['V'] + x_t_i)  # Uniquement vaccination de campagne

        nouvelle_envie_nu = calculer_nu_dynamique(S_next[region])
        
        # On met √† jour le param√®tre moyen pour le futur SAA
        S_next['P_mean'][region]['nu'] = nouvelle_envie_nu

    return S_next

# =============================================================================
# FONCTION GLOBALE
# =============================================================================

def run_dlp(S_initial, T_horizon, M_scenarios, costs, K_renouv_func):
    """
    Ex√©cute la politique Direct Lookahead (DLA) avec SAA sur T p√©riodes
    """
    S_t = copy.deepcopy(S_initial)
    history = [copy.deepcopy(S_initial)]

    print(f"\n{'='*80}")
    print(f"D√âMARRAGE SAA (Horizon T={T_horizon})")
    print(f"{'='*80}")

    for t in range(T_horizon):
        # R√©solution du probl√®me SAA
        x_t_star = solve_saa_problem(S_t, M_scenarios, costs)
        
        # Pr√©paration de l'affichage
        total_allocated = sum(x_t_star.values())
        stock_dispo = S_t['Stock']['K']
        regions_list = [k for k in S_t.keys() if k not in ['Stock', 't', 'P_mean']]
        print(f"\n--- P√©riode t={t} (Stock dispo: {stock_dispo:.0f}, Allou√©: {total_allocated:.0f}) ---")
        
        header = (
            f"{'R√©gion':<10} | "
            f"{'S':>7} | {'I':>6} | {'R':>6} | {'D':>5} | {'V':>6} || "
            f"{'ALLOC':>7} || "
            f"{'Beta'} | {'Nu'} | {'Alpha'} | {'Gamma'} | {'Eta'}"
        )
        print("-" * len(header))
        print(header)
        print("-" * len(header))

        for r in regions_list:
            # R√©cup√©ration des compartiments
            s_val = S_t[r].get('S', 0)
            i_val = S_t[r].get('I', 0)
            r_val = S_t[r].get('R', 0)
            d_val = S_t[r].get('D', 0)
            v_val = S_t[r].get('V', 0)
            alloc = x_t_star.get(r, 0)

            # R√©cup√©ration des param√®tres (stock√©s dans S_t['P_mean'][r])
            params = S_t['P_mean'].get(r, {})
            beta_val = params.get('beta', 0)
            nu_val = params.get('nu', 0)
            alpha_val = params.get('alpha', 0)
            gamma_val = params.get('gamma', 0)
            eta_val = params.get('eta', 0)

            print(
                f"{r:<10} | "
                f"{s_val:>7.0f} | {i_val:>6.0f} | {r_val:>6.0f} | {d_val:>5.0f} | {v_val:>6.0f} || "
                f"{alloc:>7.0f} || "
                f"{beta_val} | {nu_val} | {alpha_val} | {gamma_val} | {eta_val}"
            )


        # Transition vers l'√©tat S_t+1 en utilisant la r√©alisation r√©elle W_real
        S_t_plus_1 = update_state(S_t, x_t_star, K_renouv_func)

        # Mise √† jour de l'√©tat pour la prochaine it√©ration
        S_t = S_t_plus_1
        history.append(copy.deepcopy(S_t))

    return history

def run_pfa(S_initial, T_horizon, K_renouv_func):
    """ Ex√©cute la politique PFA (Heuristique) """
    S_t = copy.deepcopy(S_initial)
    history = [copy.deepcopy(S_initial)]

    print(f"\n{'='*80}")
    print(f"D√âMARRAGE PFA (Horizon T={T_horizon})")
    print(f"{'='*80}")

    for t in range(T_horizon):
        # 1. D√©cision (Heuristique)
        x_t_star = solve_pfa_policy(S_t)

        # 2. Affichage
        afficher_etat_periode(t, S_t, x_t_star)

        # 3. Transition R√©elle
        S_t = update_state(S_t, x_t_star, K_renouv_func)
        history.append(copy.deepcopy(S_t))

    return history 

# =============================================================================
# FONCTION D'AFFICHAGE
# =============================================================================

def afficher_etat_periode(t, S_t, x_t_star):
    """ Fonction utilitaire pour √©viter de dupliquer le code d'affichage """
    total_allocated = sum(x_t_star.values())
    stock_dispo = S_t['Stock']['K']
    regions_list = [k for k in S_t.keys() if k not in ['Stock', 't', 'P_mean']]
    
    print(f"\n--- P√©riode t={t} (Stock: {stock_dispo:.0f}, Allou√©: {total_allocated:.0f}) ---")
    
    header = f"{'R√©gion':<10} | {'S':>7} | {'I':>6} | {'R':>6} | {'D':>5} | {'V':>6} || {'ALLOC':>7} || {'Beta'} | {'Nu'} | {'Alpha'}"
    print("-" * len(header))
    print(header)
    print("-" * len(header))

    for r in regions_list:
        vals = S_t[r]
        alloc = x_t_star.get(r, 0)
        p = S_t['P_mean'].get(r, {})
        
        print(f"{r:<10} | {vals['S']:>7.0f} | {vals['I']:>6.0f} | {vals['R']:>6.0f} | {vals['D']:>5.0f} | {vals['V']:>6.0f} || {alloc:>7.0f} || {p.get('beta',0):.2f} | {p.get('nu',0):.3f} | {p.get('alpha',0):.2f}")

# =============================================================================
# FONCTION DE COMPARAISON
# =============================================================================

def compare_policies(S_initial, T_horizon, M_scenarios, costs, K_renouv_func):
    """ Lance SAA puis PFA et compare les r√©sultats finaux """
    
    # 1. Ex√©cution SAA
    history_saa = run_dlp(copy.deepcopy(S_initial), T_horizon, M_scenarios, costs, K_renouv_func)
    
    # 2. Ex√©cution PFA
    history_pfa = run_pfa(copy.deepcopy(S_initial), T_horizon, K_renouv_func)

    # 3. Calcul des r√©sultats
    regions = [k for k in S_initial.keys() if k not in ['Stock', 't', 'P_mean']]
    
    final_saa = history_saa[-1]
    final_pfa = history_pfa[-1]
    
    d_saa = sum(final_saa[r]['D'] for r in regions)
    d_pfa = sum(final_pfa[r]['D'] for r in regions)
    diff = d_pfa - d_saa # Positif = SAA a gagn√© (moins de morts)

    # Affichage du bilan
    print("\n" + "#"*60)
    print(f" BILAN FINAL (T={T_horizon})")
    print("#"*60)
    print(f"Morts Totaux SAA : {d_saa:.0f}")
    print(f"Morts Totaux PFA : {d_pfa:.0f}")
    
    if diff > 0:
        print(f"üèÜ R√âSULTAT : SAA gagne (a sauv√© {diff:.0f} vies de plus)")
    elif diff < 0:
        print(f"‚ö†Ô∏è R√âSULTAT : PFA gagne (a sauv√© {-diff:.0f} vies de plus)")
    else:
        print("ü§ù R√âSULTAT : √âgalit√© parfaite")
    print("#"*60 + "\n")

    return d_saa, d_pfa, diff

# =============================================================================
# CONFIGURATION DES SC√âNARIOS
# =============================================================================

SCENARIOS = {
    1: {
        "nom": "L'Effet d'√âchelle (Tailles vari√©es)",
        "data": S_1_INITIAL
    },
    2: {
        "nom": "La Bombe √† Retardement (Stades diff√©rents)",
        "data": S_2_INITIAL
    },
    3: {
        "nom": "Le Dilemme √âthique (Masses saines vs Foyers)",
        "data": S_3_INITIAL
    }
}

# =============================================================================
# FONCTION LANCER TEST 
# =============================================================================

def lancer_test(numero_scenario):
    if numero_scenario not in SCENARIOS:
        print(f"Erreur : Le sc√©nario {numero_scenario} n'existe pas.")
        return

    infos = SCENARIOS[numero_scenario]
    print(f" Lancement du TEST #{numero_scenario} : {infos['nom']}")
    

    compare_policies(
        copy.deepcopy(infos['data']), 
        HORIZON_T, 
        M_SCENARIOS, 
        COSTS, 
        K_renouv_func
    )

# =============================================================================
# MAIN
# =============================================================================

SCENARIO_A_CHOISIR = 1 

if __name__ == "__main__":
    lancer_test(SCENARIO_A_CHOISIR)

